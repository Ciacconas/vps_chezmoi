#!/usr/bin/zsh
#    _____ _     ____  ____  ____  ____  _____
#   /    // \   /  _ \/  __\/  _ \/  __\/__ __\
#   |  __\| |   | / \||  \/|| / \||  \/|  / \
#   | |   | |_/\| |-|||  __/| \_/||    /  | |
#   \_/   \____/\_/ \|\_/   \____/\_/\_\  \_/


## General settings
#-------------------------------------------------------------------------------

export TEXBASE=main
export LANG=en_US.UTF-8

# source function (ignore file if file does not exist)
function sourcefile {
  [[ -f "$1" ]] && source "$1"
}

# History
export HISTFILE="$HOME/.bash_history"
export HISTSIZE=10000000
setopt HIST_IGNORE_ALL_DUPS      # Delete old recorded entry if new entry is a duplicate.

# enable colors
autoload -U colors && colors

# better tab-completion
autoload -U compinit
zstyle ':completion:*' menu select
zmodload zsh/complist
compinit
_comp_options+=(globdots)   # Include hidden files.

# use vim keys in tab complete menu:
bindkey -M menuselect 'h' vi-backward-char
bindkey -M menuselect 'k' vi-up-line-or-history
bindkey -M menuselect 'l' vi-forward-char
bindkey -M menuselect 'j' vi-down-line-or-history
bindkey -v '^?' backward-delete-char

# vi mode
bindkey -v
export KEYTIMEOUT=1

# go backward and forward in history (equivalent to up/down arrow)
bindkey "^[h" up-line-or-history # alt + h
bindkey "^[l" down-line-or-history # alt + l
bindkey "^y" "" # noop

# reverse history search
bindkey -v
bindkey '^R' history-incremental-search-backward

# no more need to escape [ and ]
setopt noautonamedirs
alias rake='noglob rake'

# complecation related settings
# Define completers
zstyle ':completion:*' completer _extensions _complete _approximate
# Autocomplete options for cd instead of directory stack
zstyle ':completion:*' complete-options true
# zstyle ':completion:*' file-sort modification
zstyle ':completion:*:*:*:*:corrections' format '%F{yellow}!- %d (errors: %e) -!%f'
zstyle ':completion:*:*:*:*:descriptions' format '%F{blue}-- %D %d --%f'
# # Colors for files and directory
zstyle ':completion:*' file-list all
# # See ZSHCOMPWID "completion matching control"
zstyle ':completion:*' matcher-list '' 'm:{a-zA-Z}={A-Za-z}' 'r:|[._-]=* r:|=*' 'l:|=* r:|=*'
zstyle -e ':completion:*:(ssh|scp|sftp|rsh|rsync):hosts' hosts 'reply=(${=${${(f)"$(cat {/etc/ssh_,~/.ssh/known_}hosts(|2)(N) /dev/null)"}%%[# ]*}//,/ })'


# prompt and cursor shape based on vi mode
setopt prompt_subst
prompt(){
    retval=$1

    # # random emoji each prompt
    echo -ne "%F{yellow}‚ú®%f "

    # is root user
    [[ $UID == 0 ]] && echo -ne "%B%F{yellow}%{%GÔÅ±%} %f%b " #ÔÅ± Ôå≠
    # conda info
    if [[ ! -z $CONDA_DEFAULT_ENV ]]; then
        echo -ne "%F{blue}%{%GÓàµ%} %f" #  Û∞å†Û∞å†

        [[ $CONDA_DEFAULT_ENV != base ]] && echo -ne "%F{blue}$CONDA_DEFAULT_ENV%f "
    fi
    # virtualenv info
    if [[ ! -z $VIRTUAL_ENV ]]; then
      if [[ $VIRTUAL_ENV == "$HOME/.local/share/guv"* ]]; then
        # echo -ne "%F{yellow}%{%GÔé∞%} %f"
        echo -ne "%F{yellow}Ôáú %f"
      else
        # echo -ne "%F{yellow}%{%GÔçÅ%}%f"
        echo -ne "%F{yellow}ÔçÅ%f"
      fi
        echo -ne "%F{yellow}$(basename $VIRTUAL_ENV)%f "
        # echo $(basename $VIRTUAL_ENV)
    fi
    # path
    [[ $PWD == "/" ]] && echo -ne "%F{cyan}/%f " || echo -ne "%F{cyan}%(4~|%-1~/‚Ä¶/%2~|%3~)/%f " # ÔÑï
    # git info
    if git rev-parse --is-inside-work-tree 2> /dev/null | grep true &> /dev/null; then
        # branch_name=$(git branch --show-current | sed "s/ciacconas/ \%\{\%Güò∫\%\}/ ")
        branch_name=$(git branch --show-current | sed "s/ciacconas/üò∫ / ")
        dirty=" "
        if git status --porcelain 2> /dev/null | grep "^A\|^M\|^ M\|^??" > /dev/null 2> /dev/null; then
            dirty="*"
        fi
        # echo -ne "%F{magenta}%{%GÔÑ¶%}$branch_name$dirty%f" # ÓÇ†ÔÑ¶Óú•ÔêòÓÇ†
        echo -ne "%F{magenta}ÔÑ¶ $branch_name$dirty%f" # ÓÇ†ÔÑ¶Óú•ÔêòÓÇ†
    fi
    # prompt symbol
    [[ $retval == 0 ]] && echo -ne "%B%F{green}%{%G‚ù≠%}%f%b " || echo -ne "%B%F{red}%{%G‚ù≠%}%f%b " # ‚ûú ‚ù≠
}
rprompt(){
  retval=$1
  # return value
  [[ $retval != 0 ]] && echo -ne "%B%F{red}[$retval]%f%b "
  # user@host
  if [[ $UID == 0 ]]; then
    echo -ne "%B%F{red}root%f%b"
  else
    [[ $UID != 1000 || -n $SSH_CLIENT ]] && echo -ne "%F{yellow}$USER%f"
  fi
  if [[ -n $SSH_CLIENT ]]; then
    echo -ne "@%F{blue}$HOST%f"
  else
    echo -ne "    " # spacer
  fi
}
PROMPT="$(prompt 0)"
RPROMPT="$(rprompt 0)"
NORMAL='\e[1 q\e\\' # ‚ñà
INSERT='\e[4 q\e\\' # _   - INSERT='\e[5 q\e\\' # |
  [ -z $NVIM_LISTEN_ADDRESS ] || INSERT=$NORMAL
  echo -ne $INSERT
  function zle-keymap-select { # gets run every time the mode changes
  if [[ ${KEYMAP} == vicmd ]] || [[ $1 = 'block' ]]; then
    echo -ne $NORMAL
  elif [[ ${KEYMAP} == main ]] || [[ ${KEYMAP} == viins ]] || [[ ${KEYMAP} = '' ]] || [[ $1 = 'beam' ]]; then
    echo -ne $INSERT
  fi
  zle reset-prompt
}
function zle-line-init() { # gets run every new line
retval="$?" # should obviously always be first
echo -ne $INSERT
PROMPT="$(prompt $retval)"
RPROMPT="$(rprompt $retval)"
zle reset-prompt
}
function preexec() { # gets run at new prompt.
  echo -ne $INSERT
}
zle -N zle-keymap-select
zle -N zle-line-init


## Aliases
#-------------------------------------------------------------------------------

alias :q=exit
alias :x=exit

# zoxide
eval "$(zoxide init --cmd j zsh)"

# autosuggest
sourcefile $HOME/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh
# Change the ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE to 'fg=7'
typeset -g ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=8'
bindkey '^p' autosuggest-accept #-execute
bindkey '^n' autosuggest-accept #-execute
bindkey '^o' autosuggest-toggle # enable/disable autosuggest

## fzf
[ -f ~/.fzf.zsh ] && source $HOME/.fzf.zsh

## Load zsh-syntax-highlighting; should be last.
sourcefile $HOME/.config/zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
